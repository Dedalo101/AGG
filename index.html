<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Under Construction - AGG.homes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .text {
            font-size: 3.5rem;
            font-weight: 300;
            letter-spacing: 3px;
            color: white;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: fadeInScale 1s ease-out;
            margin-bottom: 1rem;
        }

        .subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 1px;
            animation: fadeInScale 1.2s ease-out;
        }

        .hint {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            animation: pulse 2s infinite;
            z-index: 100;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        @media (max-width: 768px) {
            .text {
                font-size: 2rem;
                letter-spacing: 2px;
            }
            .subtitle {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="content">
        <div class="text">AGG.homes</div>
        <div class="subtitle">Under Construction</div>
    </div>
    <div class="hint">Click to generate buildings â€¢ Scroll to explore</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // City generation parameters
        let cityBuildings = [];
        let cameraX = 0;
        let cameraY = 0;
        let time = 0;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Perlin-like noise for procedural generation
        function pseudoNoise(x, y, seed = 0) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
            return n - Math.floor(n);
        }

        function getTerrainHeight(x, y) {
            return (pseudoNoise(x * 0.1, y * 0.1) + 
                    pseudoNoise(x * 0.05, y * 0.05) * 0.5 +
                    pseudoNoise(x * 0.02, y * 0.02) * 0.25) / 1.75;
        }

        // Building structure
        class Building {
            constructor(gridX, gridY) {
                this.gridX = gridX;
                this.gridY = gridY;
                this.x = gridX * 60 - 30;
                this.y = gridY * 60 - 30;
                
                const noise = pseudoNoise(gridX, gridY, 1);
                this.height = Math.floor(3 + noise * 7);
                
                this.width = 40 + pseudoNoise(gridX, gridY, 2) * 20;
                this.depth = 40 + pseudoNoise(gridX, gridY, 3) * 20;
                
                this.roofColor = this.getColor(pseudoNoise(gridX, gridY, 4));
                this.wallColor = this.darken(this.roofColor, 0.7);
                this.windows = Math.floor(this.height * 2);
                
                this.wobble = 0;
                this.wobbleSpeed = 0.01 + pseudoNoise(gridX, gridY, 5) * 0.02;
            }

            getColor(val) {
                const colors = [
                    '#E8A87C', '#D97534', '#C85A2C',
                    '#B8634F', '#A0826D', '#9B7653'
                ];
                return colors[Math.floor(val * colors.length)];
            }

            darken(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.floor(parseInt(hex.substr(0, 2), 16) * factor);
                const g = Math.floor(parseInt(hex.substr(2, 2), 16) * factor);
                const b = Math.floor(parseInt(hex.substr(4, 2), 16) * factor);
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            lighten(color, factor) {
                const hex = color.replace('#', '');
                const r = Math.floor(Math.min(255, parseInt(hex.substr(0, 2), 16) * (1 + factor)));
                const g = Math.floor(Math.min(255, parseInt(hex.substr(2, 2), 16) * (1 + factor)));
                const b = Math.floor(Math.min(255, parseInt(hex.substr(4, 2), 16) * (1 + factor)));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            update(time) {
                this.wobble = Math.sin(time * this.wobbleSpeed) * 0.5;
            }

            draw(ctx, offsetX, offsetY) {
                const x = this.x - cameraX + offsetX;
                const y = this.y - cameraY + offsetY;

                const iso = {
                    // Front
                    tl: { x: x - this.width / 2, y: y - this.height - this.depth / 2 },
                    tr: { x: x + this.width / 2, y: y - this.height - this.depth / 2 },
                    bl: { x: x - this.width / 2, y: y - this.depth / 2 },
                    br: { x: x + this.width / 2, y: y - this.depth / 2 },
                    // Top
                    tl2: { x: x - this.width / 2, y: y - this.height - this.depth },
                    tr2: { x: x + this.width / 2, y: y - this.height - this.depth },
                };

                // Draw front face (walls)
                ctx.fillStyle = this.wallColor;
                ctx.beginPath();
                ctx.moveTo(iso.tl.x, iso.tl.y);
                ctx.lineTo(iso.tr.x, iso.tr.y);
                ctx.lineTo(iso.br.x, iso.br.y);
                ctx.lineTo(iso.bl.x, iso.bl.y);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw windows
                const windowColor = '#FFD700';
                const windowSize = 4;
                const windowSpacing = 6;
                for (let i = 0; i < this.windows; i++) {
                    const row = Math.floor(i / 4);
                    const col = i % 4;
                    const wX = iso.tl.x + this.width / 5 + col * windowSpacing;
                    const wY = iso.tl.y + 5 + row * windowSpacing;
                    if (wY < iso.bl.y) {
                        ctx.fillStyle = windowColor;
                        ctx.fillRect(wX, wY, windowSize, windowSize);
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(wX, wY, windowSize, windowSize);
                    }
                }

                // Draw top/roof
                ctx.fillStyle = this.roofColor;
                ctx.beginPath();
                ctx.moveTo(iso.tl.x, iso.tl.y);
                ctx.lineTo(iso.tl2.x, iso.tl2.y);
                ctx.lineTo(iso.tr2.x, iso.tr2.y);
                ctx.lineTo(iso.tr.x, iso.tr.y);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw roof highlight
                ctx.fillStyle = this.lighten(this.roofColor, 0.2);
                ctx.globalAlpha = 0.4;
                ctx.fillRect(iso.tl.x, iso.tl.y, iso.tr.x - iso.tl.x, (iso.tl2.y - iso.tl.y) * 0.3);
                ctx.globalAlpha = 1;
            }
        }

        function generateCity(centerGridX, centerGridY, radius = 5) {
            cityBuildings = [];
            for (let x = centerGridX - radius; x <= centerGridX + radius; x++) {
                for (let y = centerGridY - radius; y <= centerGridY + radius; y++) {
                    if (Math.random() > 0.3) { // 70% chance of building
                        cityBuildings.push(new Building(x, y));
                    }
                }
            }
            // Sort by distance to camera for proper rendering
            cityBuildings.sort((a, b) => {
                const distA = Math.hypot(a.gridX - cameraX/60, a.gridY - cameraY/60);
                const distB = Math.hypot(b.gridX - cameraX/60, b.gridY - cameraY/60);
                return distA - distB;
            });
        }

        function updateCity() {
            const gridX = Math.floor(cameraX / 60);
            const gridY = Math.floor(cameraY / 60);
            generateCity(gridX, gridY, 4);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a2a3a');
            gradient.addColorStop(1, '#2a3a4a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = '#3a4a5a';
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

            // Update and draw buildings
            cityBuildings.forEach(building => {
                building.update(time);
                building.draw(ctx, canvas.width / 2, canvas.height / 2);
            });

            time += 0.016; // ~60fps
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }

        // Event listeners
        document.addEventListener('click', (e) => {
            cameraX = e.clientX - canvas.width / 2;
            cameraY = e.clientY - canvas.height / 2;
            updateCity();
        });

        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraY += e.deltaY * 0.5;
            cameraX += e.deltaX * 0.5;
            updateCity();
        }, { passive: false });

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize
        generateCity(0, 0, 4);
        animate();
    </script>
</body>
</html>
