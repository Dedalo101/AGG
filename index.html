<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>Procedural City Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0e27; color: #fff; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; touch-action: none; }
        
        /* UI Panel */
        #ui { position: fixed; top: 12px; left: 12px; z-index: 1000; background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(4px); padding: 16px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.2); font-size: 13px; color: #94a3b8; min-width: 280px; }
        #ui > div { margin: 6px 0; line-height: 1.5; }
        #ui .title { color: #e2e8f0; font-weight: 600; margin-bottom: 10px; }
        #ui .control { color: #cbd5e1; font-size: 12px; }
        #ui .stat { color: #64748b; font-size: 11px; margin-top: 8px; }
        
        /* Stats */
        #stats { position: fixed; bottom: 12px; right: 12px; z-index: 1000; background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(4px); padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.2); font-size: 11px; color: #94a3b8; font-family: 'Courier New', monospace; }
        #stats div { margin: 3px 0; }
        
        /* Loading overlay */
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 14, 39, 0.8); display: flex; align-items: center; justify-content: center; z-index: 2000; color: #94a3b8; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #loading.show { opacity: 1; pointer-events: all; }
    </style>
</head> 
<body> 
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div>Click anywhere to generate city</div>
        <div>Drag to move â€¢ Scroll to zoom</div>
        <div style="margin-top: 10px; color: #666;">Right-click to remove</div>
    </div>
    <div id="info">
        Objects: <span id="buildingCount">0</span> | FPS: <span id="fps">60</span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let buildings = new Map();
        let roads = new Map();
        let trees = new Map();
        let camera = { x: 0, y: 0, zoom: 1 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let time = 0;
        let fps = 60;
        let frameCount = 0;
        let lastFpsTime = Date.now();

        const GRID_SIZE = 40;
        const BUILDING_COLORS = [
            '#E8A87C', '#D97534', '#C85A2C',
            '#B8634F', '#A0826D', '#9B7653',
            '#C4915A', '#D9A066'
        ];
        
        // Building types
        const BUILDING_TYPES = {
            RESIDENTIAL: 0,
            COMMERCIAL: 1,
            INDUSTRIAL: 2,
            OFFICE: 3,
            APARTMENT: 4,
            WAREHOUSE: 5
        };
        
        // Road types
        const ROAD_TYPES = {
            ASPHALT: 0,
            COBBLESTONE: 1,
            CONCRETE: 2
        };

        // Procedural functions
        function pseudoHash(x, y, seed = 0) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
            return n - Math.floor(n);
        }

        function getGridCoords(worldX, worldY) {
            return {
                x: Math.floor(worldX / GRID_SIZE),
                y: Math.floor(worldY / GRID_SIZE)
            };
        }

        function getWorldCoords(gridX, gridY) {
            return {
                x: gridX * GRID_SIZE,
                y: gridY * GRID_SIZE
            };
        }

        class Building {
            constructor(gridX, gridY) {
                this.gridX = gridX;
                this.gridY = gridY;
                
                const hash0 = pseudoHash(gridX, gridY, 0);
                const hash1 = pseudoHash(gridX, gridY, 1);
                const hash2 = pseudoHash(gridX, gridY, 2);
                const hash3 = pseudoHash(gridX, gridY, 3);
                const hash4 = pseudoHash(gridX, gridY, 4);
                
                // Determine building type
                this.type = Math.floor(hash0 * 6);
                
                // Type-specific properties
                if (this.type === BUILDING_TYPES.RESIDENTIAL) {
                    this.height = 3 + Math.floor(hash1 * 5);
                    this.width = 28 + hash2 * 10;
                    this.depth = 28 + hash3 * 10;
                    this.color = '#D9A066';
                } else if (this.type === BUILDING_TYPES.COMMERCIAL) {
                    this.height = 5 + Math.floor(hash1 * 6);
                    this.width = 35 + hash2 * 8;
                    this.depth = 30 + hash3 * 8;
                    this.color = '#B8634F';
                } else if (this.type === BUILDING_TYPES.INDUSTRIAL) {
                    this.height = 2 + Math.floor(hash1 * 3);
                    this.width = 50 + hash2 * 15;
                    this.depth = 45 + hash3 * 15;
                    this.color = '#808080';
                } else if (this.type === BUILDING_TYPES.OFFICE) {
                    this.height = 8 + Math.floor(hash1 * 8);
                    this.width = 32 + hash2 * 6;
                    this.depth = 32 + hash3 * 6;
                    this.color = '#A0A0C0';
                } else if (this.type === BUILDING_TYPES.APARTMENT) {
                    this.height = 6 + Math.floor(hash1 * 6);
                    this.width = 26 + hash2 * 8;
                    this.depth = 26 + hash3 * 8;
                    this.color = '#E8A87C';
                } else {
                    // WAREHOUSE
                    this.height = 3 + Math.floor(hash1 * 2);
                    this.width = 55 + hash2 * 10;
                    this.depth = 50 + hash3 * 10;
                    this.color = '#707070';
                }
                
                this.rotation = 0;
            }

            toJSON() {
                return {
                    gridX: this.gridX,
                    gridY: this.gridY,
                    type: this.type,
                    height: this.height,
                    width: this.width,
                    depth: this.depth,
                    color: this.color
                };
            }

            isometric(x, y, z) {
                const angle = Math.PI / 6;
                const sx = (x - y) * Math.cos(angle);
                const sy = (x + y) * Math.sin(angle) - z;
                return { x: sx, y: sy };
            }

            draw(ctx, camX, camY, zoom) {
                const worldPos = getWorldCoords(this.gridX, this.gridY);
                const baseX = (worldPos.x - camX) * zoom + canvas.width / 2;
                const baseY = (worldPos.y - camY) * zoom + canvas.height / 2;

                // Define corners in 3D space
                const w = this.width / 2;
                const d = this.depth / 2;
                const h = this.height * 8;

                const corners = {
                    tfl: this.isometric(-w, -d, h),
                    tfr: this.isometric(w, -d, h),
                    tbl: this.isometric(-w, d, h),
                    tbr: this.isometric(w, d, h),
                    bfl: this.isometric(-w, -d, 0),
                    bfr: this.isometric(w, -d, 0),
                    bbl: this.isometric(-w, d, 0),
                    bbr: this.isometric(w, d, 0)
                };

                ctx.save();
                ctx.globalAlpha = 0.95;

                // Front face
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(baseX + corners.tfl.x * zoom, baseY + corners.tfl.y * zoom);
                ctx.lineTo(baseX + corners.tfr.x * zoom, baseY + corners.tfr.y * zoom);
                ctx.lineTo(baseX + corners.bfr.x * zoom, baseY + corners.bfr.y * zoom);
                ctx.lineTo(baseX + corners.bfl.x * zoom, baseY + corners.bfl.y * zoom);
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 0.5;
                ctx.stroke();

                // Left face (darker)
                ctx.fillStyle = this.darken(this.color, 0.6);
                ctx.beginPath();
                ctx.moveTo(baseX + corners.tfl.x * zoom, baseY + corners.tfl.y * zoom);
                ctx.lineTo(baseX + corners.tbl.x * zoom, baseY + corners.tbl.y * zoom);
                ctx.lineTo(baseX + corners.bbl.x * zoom, baseY + corners.bbl.y * zoom);
                ctx.lineTo(baseX + corners.bfl.x * zoom, baseY + corners.bfl.y * zoom);
                ctx.fill();
                ctx.stroke();

                // Top face (lighter)
                ctx.fillStyle = this.lighten(this.color, 0.15);
                ctx.beginPath();
                ctx.moveTo(baseX + corners.tfl.x * zoom, baseY + corners.tfl.y * zoom);
                ctx.lineTo(baseX + corners.tfr.x * zoom, baseY + corners.tfr.y * zoom);
                ctx.lineTo(baseX + corners.tbr.x * zoom, baseY + corners.tbr.y * zoom);
                ctx.lineTo(baseX + corners.tbl.x * zoom, baseY + corners.tbl.y * zoom);
                ctx.fill();
                ctx.stroke();

                // Windows/details based on type
                if (this.type === BUILDING_TYPES.RESIDENTIAL || this.type === BUILDING_TYPES.COMMERCIAL || this.type === BUILDING_TYPES.OFFICE || this.type === BUILDING_TYPES.APARTMENT) {
                    const windowColor = this.type === BUILDING_TYPES.OFFICE ? '#FFE6B3' : '#FFE000';
                    const windows = Math.ceil(this.height * 1.5);
                    for (let i = 0; i < windows; i++) {
                        const row = Math.floor(i / 3);
                        const col = i % 3;
                        const wX = baseX + (corners.tfl.x + (corners.tfr.x - corners.tfl.x) * (col + 1) / 4) * zoom;
                        const wY = baseY + (corners.tfl.y + (corners.bfl.y - corners.tfl.y) * (row + 1) / (windows + 1)) * zoom;
                        
                        ctx.fillStyle = windowColor;
                        ctx.fillRect(wX - 2 * zoom, wY - 2 * zoom, 4 * zoom, 4 * zoom);
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(wX - 2 * zoom, wY - 2 * zoom, 4 * zoom, 4 * zoom);
                    }
                }

                ctx.restore();
            }

            darken(color, factor) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.max(0, Math.floor(((num >> 16) & 255) * factor));
                const g = Math.max(0, Math.floor(((num >> 8) & 255) * factor));
                const b = Math.max(0, Math.floor((num & 255) * factor));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }

            lighten(color, factor) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.min(255, Math.floor(((num >> 16) & 255) * (1 + factor)));
                const g = Math.min(255, Math.floor(((num >> 8) & 255) * (1 + factor)));
                const b = Math.min(255, Math.floor((num & 255) * (1 + factor)));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }
        }

        class Road {
            constructor(gridX, gridY) {
                this.gridX = gridX;
                this.gridY = gridY;
                const hash = pseudoHash(gridX, gridY, 100);
                this.type = Math.floor(hash * 3);
            }

            getColor() {
                const colors = ['#4A4A4A', '#9A8860', '#B0B0A8'];
                return colors[this.type];
            }

            draw(ctx, camX, camY, zoom) {
                const worldPos = getWorldCoords(this.gridX, this.gridY);
                const screenX = (worldPos.x - camX) * zoom + canvas.width / 2;
                const screenY = (worldPos.y - camY) * zoom + canvas.height / 2;
                
                // Draw road as isometric square
                const size = GRID_SIZE * 0.9 * zoom;
                const angle = Math.PI / 6;
                
                // Road corners in isometric
                const corners = [
                    { x: -GRID_SIZE / 2, y: -GRID_SIZE / 2 },
                    { x: GRID_SIZE / 2, y: -GRID_SIZE / 2 },
                    { x: GRID_SIZE / 2, y: GRID_SIZE / 2 },
                    { x: -GRID_SIZE / 2, y: GRID_SIZE / 2 }
                ];
                
                ctx.save();
                ctx.fillStyle = this.getColor();
                ctx.globalAlpha = 0.85;
                
                ctx.beginPath();
                for (let i = 0; i < corners.length; i++) {
                    const corner = corners[i];
                    const isoX = (corner.x - corner.y) * Math.cos(angle);
                    const isoY = (corner.x + corner.y) * Math.sin(angle);
                    const screenCornerX = screenX + isoX * zoom;
                    const screenCornerY = screenY + isoY * zoom;
                    
                    if (i === 0) ctx.moveTo(screenCornerX, screenCornerY);
                    else ctx.lineTo(screenCornerX, screenCornerY);
                }
                ctx.closePath();
                ctx.fill();
                
                // Road markings
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        class Tree {
            constructor(gridX, gridY) {
                this.gridX = gridX;
                this.gridY = gridY;
                const hash1 = pseudoHash(gridX, gridY, 200);
                const hash2 = pseudoHash(gridX, gridY, 201);
                this.height = 4 + Math.floor(hash1 * 4);
                this.size = 12 + hash2 * 8;
            }

            draw(ctx, camX, camY, zoom) {
                const worldPos = getWorldCoords(this.gridX, this.gridY);
                const baseX = (worldPos.x - camX) * zoom + canvas.width / 2;
                const baseY = (worldPos.y - camY) * zoom + canvas.height / 2;

                ctx.save();
                
                // Trunk
                ctx.fillStyle = '#654321';
                const trunkWidth = 4 * zoom;
                const trunkHeight = this.height * 3 * zoom;
                ctx.fillRect(baseX - trunkWidth / 2, baseY - trunkHeight, trunkWidth, trunkHeight);
                
                // Foliage (circular from isometric view)
                ctx.fillStyle = '#228B22';
                ctx.globalAlpha = 0.8;
                const canopyRadius = this.size * zoom;
                ctx.beginPath();
                ctx.arc(baseX, baseY - this.height * 3 * zoom - canopyRadius / 2, canopyRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Darker foliage layer
                ctx.fillStyle = '#1a5c1a';
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.arc(baseX - 3 * zoom, baseY - this.height * 3 * zoom - canopyRadius / 3, canopyRadius * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        function placeBuilding(worldX, worldY) {
            const grid = getGridCoords(worldX, worldY);
            
            // Generate a city block around click point
            generateCityBlock(grid.x, grid.y);
        }

        function generateCityBlock(centerX, centerY) {
            const blockSize = 15;
            const roadMap = new Map();
            const visited = new Set();
            
            // Step 1: Generate roads using wave propagation from center
            const queue = [[centerX, centerY]];
            visited.add(`${centerX},${centerY}`);
            roadMap.set(`${centerX},${centerY}`, true);
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                
                // Spread roads to adjacent cells with probability based on distance
                const distance = Math.hypot(x - centerX, y - centerY);
                
                if (distance > blockSize) continue;
                
                // Get noise-based direction preference
                const noiseValue = pseudoHash(x, y, 10);
                const directions = [
                    { dx: 1, dy: 0, weight: noiseValue > 0.7 ? 1.5 : 1 },      // right
                    { dx: -1, dy: 0, weight: noiseValue > 0.5 ? 1.5 : 1 },     // left
                    { dx: 0, dy: 1, weight: noiseValue > 0.3 ? 1.5 : 1 },      // down
                    { dx: 0, dy: -1, weight: noiseValue > 0.1 ? 1.5 : 1 },     // up
                    { dx: 1, dy: 1, weight: 0.6 },    // diagonal
                    { dx: -1, dy: -1, weight: 0.6 },  // diagonal
                    { dx: 1, dy: -1, weight: 0.6 },   // diagonal
                    { dx: -1, dy: 1, weight: 0.6 }    // diagonal
                ];
                
                // Sort directions by weight and noise
                directions.sort((a, b) => {
                    const noiseA = pseudoHash(x + a.dx, y + a.dy, 20) * a.weight;
                    const noiseB = pseudoHash(x + b.dx, y + b.dy, 20) * b.weight;
                    return noiseB - noiseA;
                });
                
                // Try to extend roads in preferred directions
                for (let i = 0; i < Math.min(3, directions.length); i++) {
                    const { dx, dy } = directions[i];
                    const nx = x + dx;
                    const ny = y + dy;
                    const key = `${nx},${ny}`;
                    const newDistance = Math.hypot(nx - centerX, ny - centerY);
                    
                    if (newDistance <= blockSize && !visited.has(key)) {
                        // Probability to continue road decreases with distance
                        const continueProbability = 0.85 - (newDistance / blockSize) * 0.3;
                        const noise = pseudoHash(nx, ny, 15);
                        
                        if (noise < continueProbability) {
                            visited.add(key);
                            roadMap.set(key, true);
                            queue.push([nx, ny]);
                        }
                    }
                }
            }
            
            // Step 2: Place buildings in clusters between roads
            for (let x = centerX - blockSize; x <= centerX + blockSize; x++) {
                for (let y = centerY - blockSize; y <= centerY + blockSize; y++) {
                    const key = `${x},${y}`;
                    
                    if (buildings.has(key) || roads.has(key) || trees.has(key)) {
                        continue;
                    }
                    
                    const isRoad = roadMap.has(key);
                    
                    // Place buildings near roads but not on them
                    if (!isRoad) {
                        let roadDistance = 999;
                        
                        // Find closest road
                        for (let dx = -3; dx <= 3; dx++) {
                            for (let dy = -3; dy <= 3; dy++) {
                                if (roadMap.has(`${x + dx},${y + dy}`)) {
                                    roadDistance = Math.min(roadDistance, Math.hypot(dx, dy));
                                }
                            }
                        }
                        
                        // Build if within 2-3 cells of a road
                        if (roadDistance > 0 && roadDistance <= 3) {
                            const rand = pseudoHash(x, y, 50);
                            if (rand > 0.2) { // 80% chance
                                buildings.set(key, new Building(x, y));
                            }
                        }
                    }
                }
            }
            
            // Step 3: Place trees in remaining empty spaces
            for (let x = centerX - blockSize; x <= centerX + blockSize; x++) {
                for (let y = centerY - blockSize; y <= centerY + blockSize; y++) {
                    const key = `${x},${y}`;
                    
                    if (buildings.has(key) || roads.has(key) || trees.has(key)) {
                        continue;
                    }
                    
                    const rand = pseudoHash(x, y, 100);
                    if (rand > 0.4) {
                        trees.set(key, new Tree(x, y));
                    }
                }
            }
            
            // Step 4: Place all roads
            roadMap.forEach((_, key) => {
                if (!roads.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    roads.set(key, new Road(x, y));
                }
            });
            
            updateCounts();
        }

        function removeBuilding(worldX, worldY) {
            const grid = getGridCoords(worldX, worldY);
            const key = `${grid.x},${grid.y}`;
            
            if (buildings.has(key)) {
                buildings.delete(key);
                updateCounts();
            } else if (roads.has(key)) {
                roads.delete(key);
                updateCounts();
            } else if (trees.has(key)) {
                trees.delete(key);
                updateCounts();
            }
        }

        function updateCounts() {
            document.getElementById('buildingCount').textContent = buildings.size + roads.size + trees.size;
        }

        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - canvas.width / 2) / camera.zoom + camera.x,
                y: (screenY - canvas.height / 2) / camera.zoom + camera.y
            };
        }

        function draw() {
            // Background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = 'rgba(80, 80, 80, 0.2)';
            ctx.lineWidth = 0.5;
            const gridStart = Math.floor(camera.x / GRID_SIZE) * GRID_SIZE;
            const gridEnd = gridStart + canvas.width / camera.zoom + GRID_SIZE;
            
            for (let x = gridStart; x < gridEnd; x += GRID_SIZE) {
                const sx = (x - camera.x) * camera.zoom + canvas.width / 2;
                ctx.beginPath();
                ctx.moveTo(sx, 0);
                ctx.lineTo(sx, canvas.height);
                ctx.stroke();
            }

            const gridYStart = Math.floor(camera.y / GRID_SIZE) * GRID_SIZE;
            const gridYEnd = gridYStart + canvas.height / camera.zoom + GRID_SIZE;
            
            for (let y = gridYStart; y < gridYEnd; y += GRID_SIZE) {
                const sy = (y - camera.y) * camera.zoom + canvas.height / 2;
                ctx.beginPath();
                ctx.moveTo(0, sy);
                ctx.lineTo(canvas.width, sy);
                ctx.stroke();
            }

            // Draw all structures sorted by depth
            const allItems = [];
            
            // Add roads
            roads.forEach(road => {
                allItems.push({ type: 'road', obj: road, depth: road.gridX + road.gridY });
            });
            
            // Add buildings
            buildings.forEach(building => {
                allItems.push({ type: 'building', obj: building, depth: building.gridX + building.gridY });
            });
            
            // Add trees
            trees.forEach(tree => {
                allItems.push({ type: 'tree', obj: tree, depth: tree.gridX + tree.gridY });
            });
            
            allItems.sort((a, b) => a.depth - b.depth);
            
            allItems.forEach(item => {
                item.obj.draw(ctx, camera.x, camera.y, camera.zoom);
            });

            time += 0.016;
        }

        function animate() {
            draw();
            
            frameCount++;
            const now = Date.now();
            if (now - lastFpsTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(animate);
        }

        // Touch tracking
        let touchStart = { x: 0, y: 0 };
        let lastTouchDistance = 0;
        let touchStartTime = 0;

        function getClientCoords(touch) {
            return {
                x: touch.clientX,
                y: touch.clientY
            };
        }

        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) { // Right click
                const worldPos = screenToWorld(e.clientX, e.clientY);
                removeBuilding(worldPos.x, worldPos.y);
            } else {
                isDragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = (e.clientX - dragStart.x) / camera.zoom;
                const dy = (e.clientY - dragStart.y) / camera.zoom;
                camera.x -= dx;
                camera.y -= dy;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('click', (e) => {
            if (!isDragging) {
                const worldPos = screenToWorld(e.clientX, e.clientY);
                placeBuilding(worldPos.x, worldPos.y);
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            camera.zoom *= e.deltaY > 0 ? 1 / zoomFactor : zoomFactor;
            camera.zoom = Math.max(0.3, Math.min(3, camera.zoom));
        }, { passive: false });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartTime = Date.now();
            
            if (e.touches.length === 1) {
                // Single touch: dragging or clicking
                const touch = e.touches[0];
                isDragging = true;
                dragStart = getClientCoords(touch);
                touchStart = dragStart;
            } else if (e.touches.length === 2) {
                // Two fingers: zoom
                isDragging = false;
                lastTouchDistance = getTouchDistance(e.touches[0], e.touches[1]);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch drag
                const touch = e.touches[0];
                const dx = (touch.clientX - dragStart.x) / camera.zoom;
                const dy = (touch.clientY - dragStart.y) / camera.zoom;
                camera.x -= dx;
                camera.y -= dy;
                dragStart = getClientCoords(touch);
            } else if (e.touches.length === 2) {
                // Two finger zoom
                const newDistance = getTouchDistance(e.touches[0], e.touches[1]);
                if (lastTouchDistance > 0) {
                    const zoomFactor = newDistance / lastTouchDistance;
                    camera.zoom *= zoomFactor;
                    camera.zoom = Math.max(0.3, Math.min(3, camera.zoom));
                }
                lastTouchDistance = newDistance;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 0) {
                // Check if it was a tap (short duration, minimal movement)
                const tapDuration = Date.now() - touchStartTime;
                const distMoved = Math.hypot(dragStart.x - touchStart.x, dragStart.y - touchStart.y);
                
                if (tapDuration < 300 && distMoved < 10) {
                    // It's a tap, place building
                    const worldPos = screenToWorld(touchStart.x, touchStart.y);
                    placeBuilding(worldPos.x, worldPos.y);
                }
                
                isDragging = false;
                lastTouchDistance = 0;
            }
        }, { passive: false });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize with some buildings
        for (let x = -3; x <= 3; x++) {
            for (let y = -3; y <= 3; y++) {
                if (Math.random() > 0.5) {
                    buildings.set(`${x},${y}`, new Building(x, y));
                }
            }
        }
        
        // Generate initial city block
        generateCityBlock(0, 0);
        
        updateCounts();

        animate();
    </script>
</body>
</html>
