<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>Procedural City Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: linear-gradient(135deg, #0a0e27 0%, #0f1f3a 100%); color: #fff; overflow: hidden; font-family: 'Segoe UI', 'Roboto', sans-serif; }
        canvas { display: block; touch-action: none; }
        
        /* Main UI Panel */
        #ui { 
            position: fixed; top: 12px; left: 12px; z-index: 1000; 
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(20, 30, 50, 0.95) 100%);
            backdrop-filter: blur(8px); 
            padding: 18px; 
            border-radius: 12px; 
            border: 2px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            transition: all 0.3s ease;
        }
        #ui:hover { border-color: rgba(59, 130, 246, 0.6); box-shadow: 0 12px 48px rgba(59, 130, 246, 0.2); }
        
        #ui > div { margin: 7px 0; line-height: 1.6; }
        #ui .title { 
            color: #3b82f6; 
            font-weight: 700; 
            margin-bottom: 14px; 
            font-size: 16px;
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
        }
        #ui .control { 
            color: #cbd5e1; 
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #ui .control::before { content: '‚ñ∏'; color: #3b82f6; font-weight: bold; }
        #ui .stat { 
            color: #64748b; 
            font-size: 11px; 
            margin-top: 10px;
            padding: 6px 0;
            border-top: 1px solid rgba(148, 163, 184, 0.1);
            padding-top: 8px;
        }
        #ui .stat strong { color: #3b82f6; }
        
        /* Toolbar */
        #toolbar {
            position: fixed;
            bottom: 12px;
            left: 12px;
            z-index: 1000;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-width: 400px;
        }
        
        .btn {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.8) 0%, rgba(37, 99, 235, 0.8) 100%);
            border: 1px solid rgba(59, 130, 246, 0.6);
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        .btn:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 1) 0%, rgba(37, 99, 235, 1) 100%);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }
        .btn:active { transform: translateY(0); }
        .btn.secondary { background: rgba(75, 85, 99, 0.7); border-color: rgba(148, 163, 184, 0.3); }
        .btn.secondary:hover { background: rgba(100, 116, 139, 0.9); }
        
        /* Stats Panel */
        #stats { 
            position: fixed; 
            bottom: 12px; 
            right: 12px; 
            z-index: 1000; 
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(20, 30, 50, 0.95) 100%);
            backdrop-filter: blur(8px); 
            padding: 14px 16px; 
            border-radius: 12px; 
            border: 2px solid rgba(34, 197, 94, 0.3);
            font-size: 11px; 
            color: #94a3b8; 
            font-family: 'Courier New', monospace;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 140px;
        }
        #stats div { 
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        #stats div strong { color: #22c55e; font-weight: 600; }
        #stats div span { text-align: right; }
        
        /* Loading overlay */
        #loading { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(10, 14, 39, 0.9); 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            z-index: 2000; 
            color: #3b82f6; 
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 0.3s;
            backdrop-filter: blur(4px);
        }
        #loading.show { opacity: 1; pointer-events: all; }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(59, 130, 246, 0.2);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        #loading-text {
            font-size: 14px;
            letter-spacing: 2px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* Legend/Info */
        .info-badge {
            display: inline-block;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            margin-top: 8px;
            color: #a5b4fc;
        }
        
        /* Animations */
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #ui { animation: slideIn 0.3s ease-out; }
    </style>
</head> 
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div class="title">üèôÔ∏è City Generator</div>
        <div class="control">Click: Generate</div>
        <div class="control">Drag: Pan</div>
        <div class="control">Scroll: Zoom</div>
        <div class="control">Right-click: Remove</div>
        <div class="stat">Objects: <strong id="buildingCount">0</strong></div>
        <div class="stat">Density: <strong id="density">0%</strong></div>
        <div class="info-badge">Double-click to clear</div>
    </div>
    
    <div id="toolbar">
        <button class="btn" id="btnGenerate">+ Generate</button>
        <button class="btn secondary" id="btnClear">üóëÔ∏è Clear All</button>
        <button class="btn secondary" id="btnReset">‚Üª Reset</button>
        <button class="btn secondary" id="btnToggleGrid">‚äû Grid</button>
    </div>
    
    <div id="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Zoom: <span id="zoomLevel">1.0</span>x</div>
        <div>Map: <span id="camPos">0,0</span></div>
        <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); margin-top: 6px; padding-top: 6px;">Size: <span id="mapSize">0KB</span></div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Generating...</div>
    </div>

    <script>
        // ============ ENHANCED CITY GENERATOR ============
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // ============ CONSTANTS ============
        const CONFIG = {
            GRID_SIZE: 40,
            BLOCK_SIZE: 16,
            MAX_ZOOM: 4,
            MIN_ZOOM: 0.25,
            ISOMETRIC_ANGLE: Math.PI / 6,
            MAX_BUILDINGS: 5000,
            ROAD_WIDTH_RATIO: 0.95
        };
        
        const BUILDING_TYPES = { RESIDENTIAL: 0, COMMERCIAL: 1, INDUSTRIAL: 2, OFFICE: 3, APARTMENT: 4, WAREHOUSE: 5 };
        const ROAD_TYPES = { ASPHALT: 0, COBBLESTONE: 1, CONCRETE: 2 };
        const BUILDING_COLORS = {
            0: '#E8A87C', 1: '#D97534', 2: '#C85A2C',
            3: '#B8634F', 4: '#A0826D', 5: '#9B7653'
        };
        
        // ============ GAME STATE ============
        const gameState = {
            buildings: new Map(),
            roads: new Map(),
            trees: new Map(),
            camera: { x: 0, y: 0, zoom: 1 },
            time: 0,
            isDragging: false,
            lastClick: { x: 0, y: 0, time: 0 }
        };
        
        // ============ PERFORMANCE MONITORING ============
        const perf = {
            fps: 60,
            frameCount: 0,
            lastTime: Date.now(),
            avgFrameTime: 0
        };
        
        // ============ OPTIMIZED NOISE FUNCTION ============
        function noise2D(x, y, seed = 0) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed * 45.164) * 43758.5453;
            return n - Math.floor(n);
        }
        
        // ============ COORDINATE CONVERSION ============
        function gridToWorld(gx, gy) {
            return { x: gx * CONFIG.GRID_SIZE, y: gy * CONFIG.GRID_SIZE };
        }
        
        function worldToGrid(wx, wy) {
            return { x: Math.floor(wx / CONFIG.GRID_SIZE), y: Math.floor(wy / CONFIG.GRID_SIZE) };
        }
        
        function screenToWorld(sx, sy) {
            return {
                x: (sx - canvas.width / 2) / gameState.camera.zoom + gameState.camera.x,
                y: (sy - canvas.height / 2) / gameState.camera.zoom + gameState.camera.y
            };
        }
        
        function worldToScreen(wx, wy) {
            return {
                x: (wx - gameState.camera.x) * gameState.camera.zoom + canvas.width / 2,
                y: (wy - gameState.camera.y) * gameState.camera.zoom + canvas.height / 2
            };
        }
        
        // ============ ISOMETRIC PROJECTION ============
        function isometric(x, y, z = 0) {
            const angle = CONFIG.ISOMETRIC_ANGLE;
            return {
                x: (x - y) * Math.cos(angle),
                y: (x + y) * Math.sin(angle) - z
            };
        }
        
        // ============ COLOR UTILITIES ============
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, Math.round(x))).toString(16).padStart(2, '0')).join('');
        }
        
        function darken(color, factor) {
            const rgb = hexToRgb(color);
            return rgbToHex(rgb.r * factor, rgb.g * factor, rgb.b * factor);
        }
        
        function lighten(color, factor) {
            const rgb = hexToRgb(color);
            return rgbToHex(rgb.r * (1 + factor), rgb.g * (1 + factor), rgb.b * (1 + factor));
        }
        
        // ============ BUILDING CLASS ============
        class Building {
            constructor(gx, gy) {
                this.gx = gx;
                this.gy = gy;
                const h0 = noise2D(gx, gy, 0);
                const h1 = noise2D(gx, gy, 1);
                const h2 = noise2D(gx, gy, 2);
                
                this.type = Math.floor(h0 * 6);
                this.color = BUILDING_COLORS[this.type];
                
                // Type-specific dimensions
                const typeProps = [
                    { h: 3 + Math.floor(h1 * 5), w: 28 + h2 * 10, d: 28 + h2 * 10 },  // RESIDENTIAL
                    { h: 5 + Math.floor(h1 * 6), w: 35 + h2 * 8, d: 30 + h2 * 8 },    // COMMERCIAL
                    { h: 2 + Math.floor(h1 * 3), w: 50 + h2 * 15, d: 45 + h2 * 15 },  // INDUSTRIAL
                    { h: 8 + Math.floor(h1 * 8), w: 32 + h2 * 6, d: 32 + h2 * 6 },    // OFFICE
                    { h: 6 + Math.floor(h1 * 6), w: 26 + h2 * 8, d: 26 + h2 * 8 },    // APARTMENT
                    { h: 3 + Math.floor(h1 * 2), w: 55 + h2 * 10, d: 50 + h2 * 10 }   // WAREHOUSE
                ];
                
                const props = typeProps[this.type];
                this.height = props.h;
                this.width = props.w;
                this.depth = props.d;
            }
            
            draw(ctx) {
                const world = gridToWorld(this.gx, this.gy);
                const screen = worldToScreen(world.x, world.y);
                const w = this.width / 2;
                const d = this.depth / 2;
                const h = this.height * 8;
                
                const corners = {
                    tfl: isometric(-w, -d, h),
                    tfr: isometric(w, -d, h),
                    tbl: isometric(-w, d, h),
                    tbr: isometric(w, d, h),
                    bfl: isometric(-w, -d, 0),
                    bfr: isometric(w, -d, 0),
                    bbl: isometric(-w, d, 0),
                    bbr: isometric(w, d, 0)
                };
                
                ctx.save();
                ctx.globalAlpha = 0.92;
                
                // Front face
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(screen.x + corners.tfl.x * gameState.camera.zoom, screen.y + corners.tfl.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.tfr.x * gameState.camera.zoom, screen.y + corners.tfr.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.bfr.x * gameState.camera.zoom, screen.y + corners.bfr.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.bfl.x * gameState.camera.zoom, screen.y + corners.bfl.y * gameState.camera.zoom);
                ctx.fill();
                
                // Left face
                ctx.fillStyle = darken(this.color, 0.6);
                ctx.beginPath();
                ctx.moveTo(screen.x + corners.tfl.x * gameState.camera.zoom, screen.y + corners.tfl.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.tbl.x * gameState.camera.zoom, screen.y + corners.tbl.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.bbl.x * gameState.camera.zoom, screen.y + corners.bbl.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.bfl.x * gameState.camera.zoom, screen.y + corners.bfl.y * gameState.camera.zoom);
                ctx.fill();
                
                // Top face
                ctx.fillStyle = lighten(this.color, 0.2);
                ctx.beginPath();
                ctx.moveTo(screen.x + corners.tfl.x * gameState.camera.zoom, screen.y + corners.tfl.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.tfr.x * gameState.camera.zoom, screen.y + corners.tfr.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.tbr.x * gameState.camera.zoom, screen.y + corners.tbr.y * gameState.camera.zoom);
                ctx.lineTo(screen.x + corners.tbl.x * gameState.camera.zoom, screen.y + corners.tbl.y * gameState.camera.zoom);
                ctx.fill();
                
                // Windows
                if ([0, 1, 3, 4].includes(this.type)) {
                    const windowColor = this.type === 3 ? '#FFE6B3' : '#FFE000';
                    const windows = Math.ceil(this.height * 1.2);
                    ctx.fillStyle = windowColor;
                    for (let i = 0; i < windows; i++) {
                        const row = Math.floor(i / 3);
                        const col = i % 3;
                        const wX = screen.x + (corners.tfl.x + (corners.tfr.x - corners.tfl.x) * (col + 1) / 4) * gameState.camera.zoom;
                        const wY = screen.y + (corners.tfl.y + (corners.bfl.y - corners.tfl.y) * (row + 1) / (windows + 1)) * gameState.camera.zoom;
                        ctx.fillRect(wX - 2 * gameState.camera.zoom, wY - 2 * gameState.camera.zoom, 4 * gameState.camera.zoom, 4 * gameState.camera.zoom);
                    }
                }
                
                ctx.restore();
            }
        }
        
        // ============ ROAD CLASS ============
        class Road {
            constructor(gx, gy) {
                this.gx = gx;
                this.gy = gy;
                this.type = Math.floor(noise2D(gx, gy, 100) * 3);
            }
            
            getColor() {
                const colors = ['#4A4A4A', '#9A8860', '#B0B0A8'];
                return colors[this.type];
            }
            
            draw(ctx) {
                const world = gridToWorld(this.gx, this.gy);
                const screen = worldToScreen(world.x, world.y);
                const z = 0;
                
                const corners = [
                    isometric(-CONFIG.GRID_SIZE / 2, -CONFIG.GRID_SIZE / 2, z),
                    isometric(CONFIG.GRID_SIZE / 2, -CONFIG.GRID_SIZE / 2, z),
                    isometric(CONFIG.GRID_SIZE / 2, CONFIG.GRID_SIZE / 2, z),
                    isometric(-CONFIG.GRID_SIZE / 2, CONFIG.GRID_SIZE / 2, z)
                ];
                
                ctx.save();
                ctx.fillStyle = this.getColor();
                ctx.globalAlpha = 0.9;
                
                ctx.beginPath();
                for (let i = 0; i < corners.length; i++) {
                    const c = corners[i];
                    const x = screen.x + c.x * gameState.camera.zoom;
                    const y = screen.y + c.y * gameState.camera.zoom;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // ============ TREE CLASS ============
        class Tree {
            constructor(gx, gy) {
                this.gx = gx;
                this.gy = gy;
                const h1 = noise2D(gx, gy, 200);
                const h2 = noise2D(gx, gy, 201);
                this.height = 3 + Math.floor(h1 * 5);
                this.size = 14 + h2 * 10;
            }
            
            draw(ctx) {
                const world = gridToWorld(this.gx, this.gy);
                const screen = worldToScreen(world.x, world.y);
                
                ctx.save();
                
                // Trunk
                ctx.fillStyle = '#8B6F47';
                const trunkW = 5 * gameState.camera.zoom;
                const trunkH = this.height * 3 * gameState.camera.zoom;
                ctx.fillRect(screen.x - trunkW / 2, screen.y - trunkH, trunkW, trunkH);
                
                // Foliage
                ctx.fillStyle = '#2D5A2D';
                ctx.globalAlpha = 0.85;
                const canopyR = this.size * gameState.camera.zoom;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y - this.height * 3 * gameState.camera.zoom - canopyR / 2, canopyR, 0, Math.PI * 2);
                ctx.fill();
                
                // Shadow layer
                ctx.fillStyle = '#1a3a1a';
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.arc(screen.x - 3 * gameState.camera.zoom, screen.y - this.height * 3 * gameState.camera.zoom - canopyR / 3, canopyR * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // ============ PROCEDURAL GENERATION ============
        function generateCityBlock(centerGx, centerGy) {
            const blockSize = 20; // Larger block for screen fill
            const roadMap = new Map();
            const visited = new Set();
            
            // Queue-based BFS for road generation
            const queue = [[centerGx, centerGy, 0]];
            visited.add(`${centerGx},${centerGy}`);
            roadMap.set(`${centerGx},${centerGy}`, true);
            
            let processedCount = 0;
            const maxProcessed = 1000; // Prevent infinite loops
            
            while (queue.length > 0 && processedCount < maxProcessed) {
                processedCount++;
                const [x, y, depth] = queue.shift();
                
                // Roads propagate outward with decreasing probability
                if (depth > blockSize) continue;
                
                // Get noise seed for this position
                const seed = noise2D(x, y, 42);
                
                // Define 8 directions with specific weights
                const directions = [
                    { dx: 1, dy: 0, name: 'E' },   // East
                    { dx: -1, dy: 0, name: 'W' },  // West
                    { dx: 0, dy: 1, name: 'S' },   // South
                    { dx: 0, dy: -1, name: 'N' },  // North
                    { dx: 1, dy: 1, name: 'SE' },  // Southeast
                    { dx: -1, dy: -1, name: 'NW' }, // Northwest
                    { dx: 1, dy: -1, name: 'NE' },  // Northeast
                    { dx: -1, dy: 1, name: 'SW' }   // Southwest
                ];
                
                // Sort directions by noise to create patterns
                directions.sort((a, b) => {
                    return noise2D(x + b.dx, y + b.dy, 100) - noise2D(x + a.dx, y + a.dy, 100);
                });
                
                // Propagate to up to 3 neighboring cells
                let branches = 0;
                for (let dir of directions) {
                    if (branches >= 3) break;
                    
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    const key = `${nx},${ny}`;
                    
                    if (visited.has(key)) continue;
                    
                    const dist = Math.hypot(nx - centerGx, ny - centerGy);
                    if (dist > blockSize) continue;
                    
                    // Probability decreases with distance
                    const baseProbability = 0.9 - (dist / blockSize) * 0.4;
                    const noise = noise2D(nx, ny, 12);
                    
                    if (noise < baseProbability) {
                        visited.add(key);
                        roadMap.set(key, true);
                        queue.push([nx, ny, depth + 1]);
                        branches++;
                    }
                }
            }
            
            // Place buildings adjacent to roads
            for (let x = centerGx - blockSize - 2; x <= centerGx + blockSize + 2; x++) {
                for (let y = centerGy - blockSize - 2; y <= centerGy + blockSize + 2; y++) {
                    const key = `${x},${y}`;
                    
                    // Skip if already occupied
                    if (gameState.buildings.has(key) || gameState.roads.has(key) || gameState.trees.has(key)) {
                        continue;
                    }
                    
                    if (!roadMap.has(key)) {
                        // Check proximity to roads
                        let nearRoad = false;
                        for (let dx = -2; dx <= 2; dx++) {
                            for (let dy = -2; dy <= 2; dy++) {
                                if (roadMap.has(`${x + dx},${y + dy}`)) {
                                    nearRoad = true;
                                    break;
                                }
                            }
                            if (nearRoad) break;
                        }
                        
                        // Place building with probability
                        if (nearRoad && noise2D(x, y, 50) > 0.25) {
                            gameState.buildings.set(key, new Building(x, y));
                        }
                    }
                }
            }
            
            // Place FEWER trees - much lower density
            for (let x = centerGx - blockSize - 2; x <= centerGx + blockSize + 2; x++) {
                for (let y = centerGy - blockSize - 2; y <= centerGy + blockSize + 2; y++) {
                    const key = `${x},${y}`;
                    
                    if (gameState.buildings.has(key) || gameState.roads.has(key) || gameState.trees.has(key)) {
                        continue;
                    }
                    
                    // Only 10-15% chance of trees (was 35-40%)
                    if (noise2D(x, y, 200) > 0.85) {
                        gameState.trees.set(key, new Tree(x, y));
                    }
                }
            }
            
            // Place all roads from roadMap
            roadMap.forEach((_, key) => {
                if (!gameState.roads.has(key)) {
                    const [x, y] = key.split(',').map(Number);
                    gameState.roads.set(key, new Road(x, y));
                }
            });
            
            updateUI();
        }
        
        function clearAll() {
            gameState.buildings.clear();
            gameState.roads.clear();
            gameState.trees.clear();
            updateUI();
        }
        
        function removeAt(wx, wy) {
            const grid = worldToGrid(wx, wy);
            const key = `${grid.x},${grid.y}`;
            
            if (gameState.buildings.has(key)) gameState.buildings.delete(key);
            else if (gameState.roads.has(key)) gameState.roads.delete(key);
            else if (gameState.trees.has(key)) gameState.trees.delete(key);
            
            updateUI();
        }
        
        // ============ UI UPDATE ============
        function updateUI() {
            const total = gameState.buildings.size + gameState.roads.size + gameState.trees.size;
            document.getElementById('buildingCount').textContent = total;
            
            const maxObjects = CONFIG.BLOCK_SIZE * CONFIG.BLOCK_SIZE * 3;
            const density = Math.round((total / maxObjects) * 100);
            document.getElementById('density').textContent = density + '%';
            
            document.getElementById('zoomLevel').textContent = gameState.camera.zoom.toFixed(1);
            document.getElementById('camPos').textContent = Math.round(gameState.camera.x) + ',' + Math.round(gameState.camera.y);
        }
        
        // ============ RENDERING ============
        function render() {
            // Clear background
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(100, 116, 139, 0.15)';
            ctx.lineWidth = 0.5;
            
            const gridStart = Math.floor(gameState.camera.x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
            for (let x = gridStart; x < gridStart + canvas.width / gameState.camera.zoom + CONFIG.GRID_SIZE; x += CONFIG.GRID_SIZE) {
                const sx = (x - gameState.camera.x) * gameState.camera.zoom + canvas.width / 2;
                ctx.beginPath();
                ctx.moveTo(sx, 0);
                ctx.lineTo(sx, canvas.height);
                ctx.stroke();
            }
            
            const gridYStart = Math.floor(gameState.camera.y / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
            for (let y = gridYStart; y < gridYStart + canvas.height / gameState.camera.zoom + CONFIG.GRID_SIZE; y += CONFIG.GRID_SIZE) {
                const sy = (y - gameState.camera.y) * gameState.camera.zoom + canvas.height / 2;
                ctx.beginPath();
                ctx.moveTo(0, sy);
                ctx.lineTo(canvas.width, sy);
                ctx.stroke();
            }
            
            // Sort and draw all objects
            const items = [];
            gameState.roads.forEach(r => items.push({ depth: r.gx + r.gy, obj: r }));
            gameState.buildings.forEach(b => items.push({ depth: b.gx + b.gy, obj: b }));
            gameState.trees.forEach(t => items.push({ depth: t.gx + t.gy, obj: t }));
            
            items.sort((a, b) => a.depth - b.depth);
            items.forEach(item => item.obj.draw(ctx));
        }
        
        // ============ ANIMATION LOOP ============
        function animate() {
            render();
            
            // FPS counter
            perf.frameCount++;
            const now = Date.now();
            if (now - perf.lastTime >= 1000) {
                perf.fps = perf.frameCount;
                document.getElementById('fps').textContent = perf.fps;
                perf.frameCount = 0;
                perf.lastTime = now;
            }
            
            requestAnimationFrame(animate);
        }
        
        // ============ INPUT HANDLERS ============
        let touchState = { startX: 0, startY: 0, startTime: 0, distance: 0 };
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                const world = screenToWorld(e.clientX, e.clientY);
                removeAt(world.x, world.y);
            } else {
                gameState.isDragging = true;
                gameState.lastClick = { x: e.clientX, y: e.clientY, time: Date.now() };
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (gameState.isDragging) {
                const dx = (e.clientX - gameState.lastClick.x) / gameState.camera.zoom;
                const dy = (e.clientY - gameState.lastClick.y) / gameState.camera.zoom;
                gameState.camera.x -= dx;
                gameState.camera.y -= dy;
                gameState.lastClick = { x: e.clientX, y: e.clientY };
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            gameState.isDragging = false;
        });
        
        canvas.addEventListener('click', (e) => {
            const now = Date.now();
            if (now - gameState.lastClick.time < 300) {
                // Double click: clear all
                clearAll();
                showNotification('Map cleared!');
            } else {
                // Single click: regenerate at that location
                const world = screenToWorld(e.clientX, e.clientY);
                const grid = worldToGrid(world.x, world.y);
                
                // Clear nearby area first
                const clearRadius = 20;
                const keysToDelete = [];
                gameState.buildings.forEach((_, key) => {
                    const [bx, by] = key.split(',').map(Number);
                    if (Math.hypot(bx - grid.x, by - grid.y) < clearRadius) {
                        keysToDelete.push(key);
                    }
                });
                gameState.roads.forEach((_, key) => {
                    const [rx, ry] = key.split(',').map(Number);
                    if (Math.hypot(rx - grid.x, ry - grid.y) < clearRadius) {
                        keysToDelete.push(key);
                    }
                });
                gameState.trees.forEach((_, key) => {
                    const [tx, ty] = key.split(',').map(Number);
                    if (Math.hypot(tx - grid.x, ty - grid.y) < clearRadius) {
                        keysToDelete.push(key);
                    }
                });
                
                keysToDelete.forEach(key => {
                    gameState.buildings.delete(key);
                    gameState.roads.delete(key);
                    gameState.trees.delete(key);
                });
                
                // Generate new layout
                generateCityBlock(grid.x, grid.y);
                showNotification('New layout generated!');
            }
            gameState.lastClick.time = now;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = 1.15;
            gameState.camera.zoom *= e.deltaY > 0 ? 1 / factor : factor;
            gameState.camera.zoom = Math.max(CONFIG.MIN_ZOOM, Math.min(CONFIG.MAX_ZOOM, gameState.camera.zoom));
        }, { passive: false });
        
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchState.startTime = Date.now();
            
            if (e.touches.length === 1) {
                gameState.isDragging = true;
                touchState.startX = e.touches[0].clientX;
                touchState.startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                gameState.isDragging = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchState.distance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const dx = (e.touches[0].clientX - touchState.startX) / gameState.camera.zoom;
                const dy = (e.touches[0].clientY - touchState.startY) / gameState.camera.zoom;
                gameState.camera.x -= dx;
                gameState.camera.y -= dy;
                touchState.startX = e.touches[0].clientX;
                touchState.startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.sqrt(dx * dx + dy * dy);
                if (touchState.distance > 0) {
                    gameState.camera.zoom *= newDist / touchState.distance;
                    gameState.camera.zoom = Math.max(CONFIG.MIN_ZOOM, Math.min(CONFIG.MAX_ZOOM, gameState.camera.zoom));
                }
                touchState.distance = newDist;
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 0) {
                const duration = Date.now() - touchState.startTime;
                if (duration < 250) {
                    const world = screenToWorld(touchState.startX, touchState.startY);
                    const grid = worldToGrid(world.x, world.y);
                    generateCityBlock(grid.x, grid.y);
                }
                gameState.isDragging = false;
            }
        }, { passive: false });
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // ============ BUTTON EVENTS ============
        document.getElementById('btnGenerate').addEventListener('click', () => {
            const grid = worldToGrid(gameState.camera.x, gameState.camera.y);
            generateCityBlock(grid.x, grid.y);
            showNotification('City generated!');
        });
        
        document.getElementById('btnClear').addEventListener('click', () => {
            if (confirm('Clear all objects? This cannot be undone.')) {
                clearAll();
                showNotification('Map cleared!');
            }
        });
        
        document.getElementById('btnReset').addEventListener('click', () => {
            gameState.camera = { x: 0, y: 0, zoom: 1 };
            showNotification('Camera reset!');
        });
        
        let showGrid = true;
        document.getElementById('btnToggleGrid').addEventListener('click', (e) => {
            showGrid = !showGrid;
            e.target.style.opacity = showGrid ? '1' : '0.5';
            showNotification(showGrid ? 'Grid ON' : 'Grid OFF');
        });
        
        // ============ NOTIFICATIONS ============
        function showNotification(msg) {
            const notif = document.createElement('div');
            notif.textContent = msg;
            notif.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(59, 130, 246, 0.9);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                z-index: 3000;
                pointer-events: none;
                animation: slideDown 0.4s ease-out;
                box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
            `;
            document.body.appendChild(notif);
            setTimeout(() => {
                notif.style.animation = 'slideUp 0.4s ease-in';
                setTimeout(() => notif.remove(), 400);
            }, 2000);
        }
        
        // ============ MAP SIZE CALCULATOR ============
        function calculateMapSize() {
            const total = gameState.buildings.size + gameState.roads.size + gameState.trees.size;
            const bytes = total * 100; // Approximate bytes per object
            if (bytes > 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
            if (bytes > 1024) return (bytes / 1024).toFixed(1) + 'KB';
            return bytes + 'B';
        }
        
        // ============ RENDER WITH GRID TOGGLE ============
        function render() {
            // Clear background
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid (toggle-able)
            if (showGrid) {
                ctx.strokeStyle = 'rgba(100, 116, 139, 0.15)';
                ctx.lineWidth = 0.5;
                
                const gridStart = Math.floor(gameState.camera.x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
                for (let x = gridStart; x < gridStart + canvas.width / gameState.camera.zoom + CONFIG.GRID_SIZE; x += CONFIG.GRID_SIZE) {
                    const sx = (x - gameState.camera.x) * gameState.camera.zoom + canvas.width / 2;
                    ctx.beginPath();
                    ctx.moveTo(sx, 0);
                    ctx.lineTo(sx, canvas.height);
                    ctx.stroke();
                }
                
                const gridYStart = Math.floor(gameState.camera.y / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
                for (let y = gridYStart; y < gridYStart + canvas.height / gameState.camera.zoom + CONFIG.GRID_SIZE; y += CONFIG.GRID_SIZE) {
                    const sy = (y - gameState.camera.y) * gameState.camera.zoom + canvas.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, sy);
                    ctx.lineTo(canvas.width, sy);
                    ctx.stroke();
                }
            }
            
            // Sort and draw all objects
            const items = [];
            gameState.roads.forEach(r => items.push({ depth: r.gx + r.gy, obj: r }));
            gameState.buildings.forEach(b => items.push({ depth: b.gx + b.gy, obj: b }));
            gameState.trees.forEach(t => items.push({ depth: t.gx + t.gy, obj: t }));
            
            items.sort((a, b) => a.depth - b.depth);
            items.forEach(item => item.obj.draw(ctx));
        }
        
        // ============ UPDATE UI ============
        function updateUI() {
            const total = gameState.buildings.size + gameState.roads.size + gameState.trees.size;
            document.getElementById('buildingCount').textContent = total;
            
            const maxObjects = CONFIG.BLOCK_SIZE * CONFIG.BLOCK_SIZE * 3;
            const density = Math.round((total / maxObjects) * 100);
            document.getElementById('density').textContent = density + '%';
            
            document.getElementById('zoomLevel').textContent = gameState.camera.zoom.toFixed(1);
            document.getElementById('camPos').textContent = Math.round(gameState.camera.x) + ',' + Math.round(gameState.camera.y);
            document.getElementById('mapSize').textContent = calculateMapSize();
        }
        
        // ============ ANIMATION LOOP ============
        function animate() {
            render();
            
            // FPS counter
            perf.frameCount++;
            const now = Date.now();
            if (now - perf.lastTime >= 1000) {
                perf.fps = perf.frameCount;
                document.getElementById('fps').textContent = perf.fps;
                perf.frameCount = 0;
                perf.lastTime = now;
            }
            
            requestAnimationFrame(animate);
        }
        
        // ============ INITIALIZATION ============
        // Generate initial city at multiple centers to fill screen
        generateCityBlock(0, 0);
        generateCityBlock(15, 0);
        generateCityBlock(-15, 0);
        generateCityBlock(0, 15);
        generateCityBlock(0, -15);
        generateCityBlock(15, 15);
        generateCityBlock(-15, -15);
        generateCityBlock(15, -15);
        generateCityBlock(-15, 15);
        
        updateUI();
        animate();
        
        // Add CSS animations to document
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { opacity: 0; transform: translate(-50%, -60px); }
                to { opacity: 1; transform: translate(-50%, -50%); }
            }
            @keyframes slideUp {
                from { opacity: 1; transform: translate(-50%, -50%); }
                to { opacity: 0; transform: translate(-50%, -60px); }
            }
        `;
        document.head.appendChild(style);
    </script>
